# Production Docker Compose - Optimized for production deployment

services:
  # Backend API service
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: runtime  # Use runtime stage for production
    ports:
      - "5000:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ASPNETCORE_URLS=http://+:8080
      - ConnectionStrings__DefaultConnection=Data Source=/app/data/library.db
      - CORS__AllowedOrigins=${FRONTEND_URL:-http://localhost}
      - Logging__LogLevel__Default=Information
      - Logging__LogLevel__Microsoft=Warning
      - Logging__LogLevel__System=Warning
    volumes:
      - backend-data:/app/data
      - backend-logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    networks:
      - library-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Frontend service (Nginx with React build)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: runtime  # Use runtime stage for production
    ports:
      - "80:80"
      - "443:443"  # HTTPS support
    environment:
      - NODE_ENV=production
    volumes:
      - ./ssl:/etc/nginx/ssl:ro  # SSL certificates (if available)
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.25'
          memory: 128M
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - library-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Reverse proxy and load balancer (Nginx)
  reverse-proxy:
    image: nginx:alpine
    ports:
      - "8080:80"  # Alternative access point
    volumes:
      - ./nginx/production.conf:/etc/nginx/conf.d/default.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3
    restart: always
    depends_on:
      - frontend
      - backend
    networks:
      - library-network
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

  # Production database backup service
  db-backup:
    image: alpine:latest
    volumes:
      - backend-data:/source/data:ro
      - backup-data:/backup
    environment:
      - BACKUP_SCHEDULE=${BACKUP_SCHEDULE:-0 2 * * *}  # Daily at 2 AM
    command: |
      sh -c '
        apk add --no-cache sqlite dcron
        echo "$BACKUP_SCHEDULE cp /source/data/library.db /backup/library-$(date +%Y%m%d_%H%M%S).db && find /backup -name \"library-*.db\" -mtime +7 -delete" | crontab -
        crond -f
      '
    restart: always
    depends_on:
      - backend
    networks:
      - library-network
    profiles:
      - backup  # Optional service, start with: docker-compose -f docker-compose.prod.yml --profile backup up

networks:
  library-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  backend-data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_DIR:-./data}
  backend-logs:
    driver: local
  backup-data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${BACKUP_DIR:-./backups}